set shell bash
set shellopts '-eu'
set ifs "\n"

#----- settings

# formats
set cursorparentfmt "\033[7m"
set cursorpreviewfmt ""
set borderfmt "\033[39;49;1m"
set numberfmt "\033[93;49"
set timefmt "_2/Jan/2006 15:04"
set infotimefmtnew "_2|Jan 15:04"
set infotimefmtold "_2|Jan  2006"
set promptfmt "\033[37;40m %u@%h \033[0m\033[30;49m\033[34;49;1m %w/%f \033[0m"

# look'n feel
set anchorfind
set dircounts
set dirfirst
set drawbox
set hidden
set icons
set incsearch
set info size:time
set period 1
set ratios '1:2:3'
set relativenumber
set scrolloff 2
set smartcase
set sortby natural
set tabstop 2
set watch true

# previews
set preview
set sixel
set previewer ~/.config/lf/preview
set cleaner ~/.config/lf/clean


#----- commands

cmd select-all :unselect; invert
cmd select-clear :select-all; unselect

# command autocompletion
cmap <enter> &{{
	if [ "$lf_mode" = command ]; then
		lf -remote "send $id complete-cmd"
	else
		lf -remote "send $id cmd-enter"
	fi
}}

cmd complete-cmd :{{
	# position cursor at the end of the first word
	cmd-home
	cmd-word

	# perform tab completion before running the command
	cmd-complete
	cmd-enter
}}

# edit-with-sudo
cmd edit-with-sudo ${{
  set -- $(cat ~/.local/share/lf/files)
  mode="$1"
  shift
  sudo -e "$fx"
  rm ~/.local/share/lf/files
  lf -remote "send clear"
}}

# Pager command
cmd pager ${{
  cols=$(tput cols)
  lines=$(tput lines)
  if [[ cols -gt 115 ]]; then
    cols=105
  else
    declare -i cols=$cols-10
  fi

	if [[ $f = *.md  ]]; then
    bash -c "glow -w ${cols} -p $fx"
	else
    bash -c "bat $fx \
			--number --theme=TwoDark --color=always --paging=always \
			--style=plain --terminal-width ${cols} --line-range :${lines} \
			--pager='less -iWQMRX~ --no-vbell'"
  fi
}}

# Replace open command with robust selection of openers
cmd open ${{
	case $(file --dereference --mime-type $f -b) in
		inode/x-empty) $EDITOR $fx ;;
		text/*) $EDITOR $fx;;
		video/*) nohup mpv $fx > /dev/null & ;;
		audio/*) nohup mpv $fx > /dev/null & ;;
		audio/midi) timidity $fx ;;
		application/epub+zip) nohup FBReader $f > /dev/null & ;;
		application/pdf) nohup zathura $f > /dev/null & ;;
		*) for f in $fx; do $OPENER $f > /dev/null 2> /dev/null & done;;
	esac
}}

# Copy the file names (including extension) of the selections separated by \n
cmd copy-filename ${{
	names="$(echo $fx | tr ' ' '\n' | xargs -I{} basename {})"
	echo $names | tr ' ' '\n' | pbcopy
}}

# Copy the absolute paths of selections separated by \n
cmd copy-absolute-path ${{
	echo $fx | tr ' ' '\n' | pbcopy
}}

# y (select for copy) and P to paste symlink
cmd create-symlink %{{
	set -- $(cat ~/.local/share/lf/files)
	mode="$1"
	shift
	if [ "$#" -lt 1 ]; then
		lf -remote "send $id echoerr no files to link"
		exit
	fi
	ln -sr -t . -- "$@"
}}

# mkdir and move files
cmd new-folder-with-selection ${{
  set -f
  echo "Directory name: "
  read newd
  mkdir -- "$newd"
  mv -- $fx "$newd"
}}

# compress current file or selected files with zip
cmd zip ${{
	if [ -f "${fx}" ]; then
		zip -qur "${fx}" $fx
	else
		zip -qr "${fx}.zip" $fx
	fi
}}

# extract compressed files
cmd extract ${{
	set -f
	out_dir="$*"

	if [ -n "$out_dir" ]; then
		mkdir -p "$out_dir"
		cd "$out_dir" || {
			lf -remote "send $id echoerr unable to create dir"
			exit 1
		}
	fi

	[ -w . ] || {
		lf -remote "send $id echoerr unable to extract to \
			\'${out_dir:-.}\'. No write permissions"
		exit 1
	}

	case "$f" in
    *.tar)
			tar -xf "$f"
    ;;
    *.tar.bz|*.tbz|*.tar.bz2|*.tbz2)
			tar -xjf "$f"
    ;;
    *.tar.gz|*.tgz)
			tar -xzf "$f"
    ;;
    *.tar.xz|*.txz)
			tar -xJf "$f"
    ;;
    *.tar.[zZ]|*.t[zZ])
			tar -xZf "$f"
    ;;
    *.tar.lz|*.tlz|*.tar.lzma|*.tlzma|*.tar.lzo|*.tzo|*.tar.zst|*.tzst)
	    tar -xaf "$f"
    ;;
    *.7z)
			7za x -- "$f"
    ;;
    *.a|*.ar)
			ar x -- "$f"
    ;;
    *.ace)
			unace e -- "$f"
    ;;
    *.alz)
			unalz -- "$f"
    ;;
    *.arc|*.ark|*.ARC|*.ARK)
			nomarch -- "$f"
    ;;
    *.arj|*.ARJ)
			arj e -r -- "$f"
		;;
    *.bz|*.bz2)
	    bunzip2 -k -- "$f"
		;;
    *.cab|*.CAB|*.exe|*.EXE)
	    cabextract "$f"
    ;;
    *.cpio)
			cpio -id -F "$f"
		;;
    *.deb)
			dpkg -x -- "$f" .
		;;
    *.gz)
			gunzip -k "$f"
    ;;
    *.lha|*.lzh)
	    lha x "$f"
    ;;
    *.lrz|*.lrzip|*.rz)
	    lrunzip -- "$f"
    ;;
    *.lz)
			lzip -d -k -- "$f"
		;;
    *.lz4)
			unlz4 -- "$f"
    ;;
    *.lzma)
			xz -d -k "$f"
    ;;
    *.lzo)
			lzop -x "$f"
    ;;
    *.rar)
			unrar x -- "$f"
    ;;
    *.src.rpm|*.rpm|*.spm)
	    rpm2cpio "$f" | cpio -dium
		;;
    *.xz)
			unxz -k -- "$f"
    ;;
    *.[zZ])
			uncompress -- "$f"
		;;
    *.zip|*.osz)
			unzip -- "$f"
    ;;
    *.zst)
			unzstd -- "$f"
    ;;
    *.AppImage)
			./"$f" --appimage-extract
		;;
    *)
			lf -remote "send $id echoerr ${f##*/} unknown archive format"
			exit 0
		;;
	esac

	if [ -n "$out_dir" ]; then
		lf -remote "send $id select '$out_dir'"
	fi

	lf -remote "send $id reload"
	lf -remote "send $id echomsg ${f##*/} extracted."
}}

# cd directories w\ zoxide
cmd z %{{
	result="$(zoxide query --exclude "$PWD" "$@" | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id cd \"$result\""
}}

# cd directories interactively w\ zoxide
cmd zi ${{
	result="$(zoxide query -i | sed 's/\\/\\\\/g;s/"/\\"/g')"
	lf -remote "send $id cd \"$result\""
}}

# search in files w/ fzf
cmd fzf_search ${{
	cmd="rg --column --line-number --no-heading --color=always --smart-case"
	fzf --ansi --disabled --header="Search in files" --delimiter=: \
			--bind="start:reload([ -n {q} ] && $cmd -- {q} || true)" \
			--bind="change:reload([ -n {q} ] && $cmd -- {q} || true)" \
			--bind='enter:become(lf -remote "send $id select \"$(printf "%s" {1} | sed '\''s/\\/\\\\/g;s/"/\\"/g'\'')\"")' \
			--preview='~/.config/lf/clean; ~/.config/lf/preview -- {1}'
}}

# helper to cd to curr dir on quit
cmd quit-and-cd &{{
	pwd > $LF_CD_FILE
	lf -remote "send $id quit"
}}

cmd reload-conf ${{
  lf -remote "send $id source ~/.config/lf/lfrc"
}}

#----- prompt

# git branch prompt
cmd on-cd &{{
	if [ "$(git rev-parse --is-inside-git-dir 2>/dev/null)" = false ]; then
		source "/etc/bash_completion.d/git-prompt"
		git=$(__git_ps1 "*%s ") || true
		fmt="\033[37;40m %u@%h \033[0m\033[30;49m\033[33;49;1m $git\033[34;49;1m%w/%f \033[0m"
	else
		fmt="\033[37;40m %u@%h \033[0m\033[30;49m\033[34;49;1m %w/%f \033[0m"
	fi

	# add to zoxide db
	if hash zoxide 2> /dev/null; then zoxide add "$PWD"; fi
	# display git repository status in your prompt
	lf -remote "send $id set promptfmt \"$fmt\""
}}
on-cd


#----- key mappings

# remove defaults
map d
map f
map F
map p
map r
map y
map w
map sa
map sb
map sc
map se

# actual mappings
map C select-clear
map R reload-conf
map q quit-and-cd
map . set hidden!

map yy copy
map yn copy-filename
map yP copy-absolute-path

map pp paste
map pP create-symlink
map pn new-folder-with-selection

map dD delete
map dd cut
map dt trash

cmap <c-right> cmd-word
cmap <c-left> cmd-word-back
cmap <c-p> cmd-yank
cmap <c-t> cmd-transpose-word
cmap <c-l> cmd-delete-word

map i pager
map I rename

map e open
map E $$EDITOR $f
map S edit-with-sudo

map o &mimeopen $f
map O push :openwith<space>

map ff filter

# fuzzy-find a file
map fF $lf -remote "send $id select $(fzf)"

# fuzzy search in files
map <c-f> :fzf_search

# enter name and compress to name.zip
map xX :zip
map xx extract

# jump-dir w\ zoxide
map zz push :z<space>
map zi :zi

# sort files
map sn :{{ set sortby natural; set info size:time; }}
map ss :{{ set sortby size; set info size:time; }}
map st :{{ set sortby time; set info size:time; }}
map sx :{{ set sortby ext; set info size:time; }}

cmap <tab> cmd-menu-complete
cmap <backtab> cmd-menu-complete-back

# show documentation
map g? $lf -doc | less

# put lf on the background
map <c-z> $ kill -STOP $PPID

# reloads current directory (r)
map r reload

# # vim: set ts=2 sw=2 tw=80 noet :
